// Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

import io.gitlab.arturbosch.detekt.Detekt
import io.gitlab.arturbosch.detekt.DetektCreateBaselineTask
import software.aws.toolkits.gradle.buildMetadata
import software.aws.toolkits.gradle.changelog.tasks.GeneratePluginChangeLog
import software.aws.toolkits.gradle.intellij.IdeFlavor
import software.aws.toolkits.gradle.intellij.IdeVersions
import software.aws.toolkits.gradle.isCi
import software.aws.toolkits.telemetry.generator.gradle.GenerateTelemetry

val toolkitVersion: String by project
val ideProfile = IdeVersions.ideProfile(project)

plugins {
    id("toolkit-kotlin-conventions")
    id("toolkit-testing")
    id("toolkit-intellij-subplugin")
    id("toolkit-integration-testing")
}

buildscript {
    dependencies {
        classpath(libs.telemetryGenerator)
    }
}

intellijToolkit {
    ideFlavor.set(IdeFlavor.IC)
}

sourceSets {
    main {
        java.srcDir("${project.buildDir}/generated-src")
    }
}

val generateTelemetry = tasks.register<GenerateTelemetry>("generateTelemetry") {
    inputFiles = listOf(file("${project.projectDir}/resources/telemetryOverride.json"))
    outputDirectory = file("${project.buildDir}/generated-src")
}

tasks.compileKotlin {
    dependsOn(generateTelemetry)
}

val changelog = tasks.register<GeneratePluginChangeLog>("pluginChangeLog") {
    includeUnreleased.set(true)
    changeLogFile.set(project.file("$buildDir/changelog/change-notes.xml"))
}

tasks.jar {
    dependsOn(changelog)
    from(changelog) {
        into("META-INF")
    }
}

val gatewayPluginXml = tasks.create<org.jetbrains.intellij.tasks.PatchPluginXmlTask>("patchPluginXmlForGateway") {
    pluginXmlFiles.set(tasks.patchPluginXml.map { it.pluginXmlFiles }.get())
    destinationDir.set(project.buildDir.resolve("patchedPluginXmlFilesGW"))

    val buildSuffix = if (!project.isCi()) "+${buildMetadata()}" else ""
    version.set("GW-$toolkitVersion-${ideProfile.shortName}$buildSuffix")
}

val gatewayArtifacts by configurations.creating {
    isCanBeConsumed = true
    isCanBeResolved = false
    // share same dependencies as default configuration
    extendsFrom(configurations["implementation"], configurations["runtimeOnly"])
}

val gatewayJar = tasks.create<Jar>("gatewayJar") {
    // META-INF/plugin.xml is a duplicate?
    // unclear why the exclude() statement didn't work
    duplicatesStrategy = DuplicatesStrategy.INCLUDE

    dependsOn(tasks.instrumentedJar)

    archiveBaseName.set("aws-toolkit-jetbrains-IC-GW")
    from(tasks.instrumentedJar.get().outputs.files.map { zipTree(it) }) {
        exclude("**/plugin.xml")
        exclude("**/plugin-intellij.xml")
        exclude("**/inactive")
    }

    from(gatewayPluginXml) {
        into("META-INF")
    }

    val pluginGateway = sourceSets.main.get().resources.first { it.name == "plugin-gateway.xml" }
    from(pluginGateway) {
        into("META-INF")
    }
}

artifacts {
    add("gatewayArtifacts", gatewayJar)
}

tasks.prepareSandbox {
    // you probably do not want to modify this.
    // this affects the IDE sandbox / build for `:jetbrains-core`, but will not propogate to the build generated by `:intellij`
    // (which is what is ultimately published to the marketplace)
    // without additional effort
}

tasks.testJar {
    // classpath.index is a duplicate
    duplicatesStrategy = DuplicatesStrategy.INCLUDE
}

tasks.processTestResources {
    // TODO how can we remove this. Fails due to:
    // "customerUploadedEventSchemaMultipleTypes.json.txt is a duplicate but no duplicate handling strategy has been set"
    duplicatesStrategy = DuplicatesStrategy.INCLUDE
}

dependencies {
    api(project(":core"))
    api(libs.aws.apacheClient)
    api(libs.aws.apprunner)
    api(libs.aws.cloudcontrol)
    api(libs.aws.cloudformation)
    api(libs.aws.cloudwatchlogs)
    api(libs.aws.codecatalyst)
    api(libs.aws.dynamodb)
    api(libs.aws.ec2)
    api(libs.aws.ecr)
    api(libs.aws.ecs)
    api(libs.aws.iam)
    api(libs.aws.lambda)
    api(libs.aws.rds)
    api(libs.aws.redshift)
    api(libs.aws.s3)
    api(libs.aws.schemas)
    api(libs.aws.secretsmanager)
    api(libs.aws.sns)
    api(libs.aws.sqs)
    api(libs.aws.services)

    implementation(project(":mynah-ui"))
    implementation(libs.aws.crt)
    implementation(libs.bundles.jackson)
    implementation(libs.zjsonpatch)
    implementation(libs.commonmark)

    testImplementation(project(path = ":core", configuration = "testArtifacts"))
    testImplementation(libs.mockk)
    testImplementation(libs.kotlin.coroutinesTest)
    testImplementation(libs.kotlin.coroutinesDebug)
    testImplementation(libs.wiremock) {
        // conflicts with transitive inclusion from docker plugin
        exclude(group = "org.apache.httpcomponents.client5")
    }

    // slf4j is v1.7.36 for <233
    // in <233, the classpass binding functionality picks up the wrong impl of StaticLoggerBinder (from the maven plugin instead of IDE platform) and causes a NoClassDefFoundError
    // instead of trying to fix the classpath, since it's built by gradle-intellij-plugin, shove slf4j >= 2.0.9 onto the test classpath, which uses a ServiceLoader and call it done
    testImplementation(libs.slf4j.api)
    testRuntimeOnly(libs.slf4j.jdk14)
}

// fix implicit dependency on generated source
tasks.withType<Detekt> {
    dependsOn(generateTelemetry)
}

tasks.withType<DetektCreateBaselineTask> {
    dependsOn(generateTelemetry)
}
